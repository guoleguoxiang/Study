# 数据库学习笔记（关系型数据库）

## table and keys

关系型数据库存储值table表格中，通过表格中的keys可以将表格和表格关联起来

## 基础语法

### 创建数据库和表

创建数据库、查看数据库和删除数据库

```sql
create database `database`; # 创建数据库cgs_demo
show databases; # 打印出所有的数据库
drop database `database`; # 删除数据库
```

创建一个表格、查看表格和删除表格

```sql
use `cgs_demo`; # 创建table之前，要先选择使用哪一个数据库
# 创建table
create table `student`(
	`student_id` int primary key, # primary key设置主键
	`name` varchar(20),
	`major` varchar(20)
	# primary key的另外一种写法
	# primary key(`student_id`)
);

describe `student`; # 查看刚才创建的表格是什么样的
drop table `student`; # 删除表格
```

给刚才创建好的表格新增某个属性

```sqlite
# 给刚才创建好的表格新增某个属性
alter table `student` add gpa decimal(3,2);
# 删除某一个属性
alter table `student` drop column gpa;
```

alter table：表示要修改一个表的结构

add：表示要向表中添加一个新列

decimal(3,2)：是新列的数据类型，表示这个列可以存储3位数字，其中2位是小位数。比如可以存储3.14不可以存储123.123



### 插入数据

如何查看表里面的信息

```sql
# 列出表格里面的所有信息
select * from `student`;
```

插入数据的两种方式

```sql
# 插入数据
insert into `student` values(1,'小白','历史');
insert into `student` values(2,'小黑','生物');
insert into `student` values(3,'小绿',NULL);
# 第二种插入方式，可以自己更改属性的顺序
insert into `student` (`name`,`major`,`student_id`) values('小红','历史',4);
```

### 限制和约束

auto_increment、not null、unique、default等等

```sql
create table `student`(
	`student_id` int AUTO_INCREMENT, # auto_increment递增
	`name` varchar(20) not null, # not null表示值不为空
	`system` varchar(20) unique # unique表示独一无二，不能重复
	`major` varchar(20) default '历史', # default默认值
	primary key(`student_id`)
);
# 使用auto_increment在插入数据的时候必须要像下面这样写好各个属性
insert into `student` (`name`,`major`) values('小红','历史');
```

### 修改和删除

```sql
# 关闭安全模式
set sql_safe_updates = 0;
```

在mysql中，如果在update和delete没有加上where条件，数据将会全部修改。不只是初识mysql的开发者会遇到这个问题，工作有一定经验的工程师难免也会忘记写入where条件。为了避免失误造成的数据全部修改和删除，可开启mysql的安全模式。

```sql
update `student` set `major`='语文' where student_id=1;
update `student` set `major`='生化' where major='语文' or major='历史';
update `student` set name='小灰', score=99 where student_id=2;

delete from student; # 删除student表格里面的所有内容
delete from student where student_id=3;
delete from student where name='小白' and score=95;
delete from student where major='语文' and score<60;
```

### 查找

```sql
select * from student;
select `name`,`major` from student;
# 按分数由低到高的顺序对其进行排序（默认asc，由低到高）
select * from student order by score; 
select * from student order by score desc; # desc是从高到低排序
# 先按照score从低到高，如果有相同的分数，再按照id进行从低到高排序
select * from student order by score, student_id; 
select * from student limit 2; # 只查找前两条数据
# 查找学科为英语，分数小于60的数据
select * from student where major='英语' and score < 60;
# 查找学科为英语，历史，或者生物的数据
select * from student where major in('英语','历史','生物');
```



## 案例

### 建表（4个）

![image-20230921104358397](C:\Users\19851\AppData\Roaming\Typora\typora-user-images\image-20230921104358397.png)

新建员工表：

​		其中emp_id为主键，branch_id和sup_id为外键，但是在employee中并没有设置外键，是因为设外键的前提是某外键所在的表要存在。

​		一会会在后面补设外键

```sql
# Employee
create table employee(
		`emp_id` int primary key,
		`name` varchar(20),
		`birth_date` date,
		`sex` varchar(1),
		`salary` int,
		`branch_id` int,
		`sup_id` int 
);
```

新建部门表：

​		这里employee已经建成功了，所以在branch可以直接设置外键

```sql
# Branch
create table branch(
		`branch_id` int primary key,
		`branch_name` varchar(20),
		`manager_id` int,
		foreign key(`manager_id`) references `employee`(`emp_id`) on delete set null # 设置外键
		
);
```

​		此时两个表都已经建成功了，可以给employee设置外键

​		外键的设置方式有两种，一种是如上所示，直接在表里设置外键

`foreign key(`manager_id`) references `employee`(`emp_id`) on delete set null`

​		第二种方式，是在表外设置外键

`alter table employee add foreign key(branch_id) references branch(branch_id) on delete set null;`

下面两行代码是为employee的branch_id 和 sup_id设置外键

```sql
# 新增外键
alter table employee add foreign key(branch_id) references branch(branch_id) on delete set null;
alter table employee add foreign key(sup_id) references employee(emp_id) on delete set null;
```

新建客户表：

```sql
# Client
create table client(
		client_id int primary key,
		client_name varchar(20),
		phone varchar(20)
);
```

新建员工和客户关联表：

​		该表展示了主键的第二种新建方式：`primary key(emp_id, client_id)`和表内设置外键

```sql
# Works_With
create table works_with(
		emp_id int,
		client_id int,
		total_sales int,
		primary key(emp_id, client_id),
		foreign key(emp_id) references employee(emp_id) on delete cascade,
		foreign key(client_id) references client(client_id) on delete cascade
);
```

### 插入数据

```sql
# 新增公司员工资料
insert into employee values(206,'小黄','1998-10-08','F',50000,1,NULL);
insert into employee values(207,'小绿','1985-09-16','M',29000,2,206);
insert into employee values(208,'小黑','2000-12-09','M',35000,3,206);
insert into employee values(209,'小白','1997-01-22','F',39000,3,207);
insert into employee values(210,'小蓝','1925-11-10','F',84000,1,207);
# 此时会新建失败，是因为对employee进行新增时，后面的对应着的部门的外键所在的表里并没有数据。
# 解决办法就是先新增branch数据，并把branch里面的外键manager_id设置为NULL，等employee数据导入时，在重新设置manager_id的值
# 新增部门资料
insert into branch values(1,'研发',NULL);
insert into branch values(2,'行政',NULL);
insert into branch values(3,'资讯',NULL);
# 更改branch表里面的manager_id
update branch set manager_id=206 where branch_id=1;
update branch set manager_id=207 where branch_id=2;
update branch set manager_id=208 where branch_id=3;
# 新增客户资料
insert into client values(400,'阿狗','25681452');
insert into client values(401,'阿猫','1546231546');
insert into client values(402,'旺财','02641354');
insert into client values(403,'鲁西','943541546');
insert into client values(404,'艾瑞克','235156441');
# 新增员工和客户关系表的资料
insert into works_with values(206,400,70000);
insert into works_with values(207,401,24000);
insert into works_with values(208,400,9800);
insert into works_with values(208,403,24000);
insert into works_with values(210,404,87940);
```

### 问题

1. 取得所有员工资料
2. 取得所有客户资料
3. 按薪水低到高取得员工资料
4. 取得薪水前3高的员工
5. 取得所有员工的名字

```sql
-- 问题
-- 1.取得所有员工资料
select * from employee;
-- 2.取得所有客户资料
select * from client;
-- 3.按薪水低到高取得员工资料
select * from employee order by salary;
-- 4.取得薪水前3高的员工
select * from employee order by salary desc limit 3;# 按照薪水由高到低排序，然后取前三
-- 5.取得所有员工的名字
select name from employee;
```

```sql
-- distinct有去重的效果
select distinct sex from employee;
```

![image-20230921141840912](C:\Users\19851\AppData\Roaming\Typora\typora-user-images\image-20230921141840912.png)

### aggregate functions聚合函数(count, avg, sum, max, min)

```sql
-- aggregate functions聚合函数
-- 1.取得员工人数
select count(*) from employee;
-- 2.取得所有出生于1970-01-01之后的女性员工人数
select count(*) from employee where birth_date<'1970-01-01' and sex='F';
-- 3.取得所有员工的平均薪水
select avg(salary) from employee;
-- 4.取得所有员工薪水的总和
select sum(salary) from employee;
-- 5.取得薪水最高的员工
select max(salary) from employee;
-- 6.取得薪水最低的员工
select min(salary) from employee;
```

### wildcards万用字元（%代表多个字元，_代表一个字元）

```sql
-- 1.取得电话号码尾数是335的客户
select * from client where phone like '%335';
-- 2.取得姓艾的客户
select * from client where client_name like '艾%';
-- 3.取得生日在12月的员工
select * from employee where birth_date like '_____12%';
```

### union合并

合并两个或多个select语句的结果

```sql
-- 1.员工名字union客户名字
# 使用union的前提，合并的属性必须一样，比如都是name或者sex或者id等
select name from employee
union
select client_name from client;

-- 2.员工id+员工名字 union 客户id+客户名字
# as可以更改属性的名字
select emp_id as total_id, name as total_name from employee
union
select client_id,client_name from client;

-- 3.员工薪水 union 销售金额
select salary from employee
union 
select total_sales from works_with;
```

### join连接

join、left join 和 right join

```sql
-- 1.取得所有部门经理的名字
# on后面跟的是条件，把符合条件的数据连接在一起
select employee.emp_id, employee.name, branch.branch_name from employee join branch on employee.emp_id=branch.manager_id;
# left join是什么意思呢？
# 当我们连接的时候左边的表格无论条件是否成立都会输出信息，右边的表格只有条件成立才会输出信息，否则输出null
select emp_id,name,branch_name from employee left join branch on emp_id=manager_id;
# 同理还有right join
select emp_id,name,branch_name from employee right join branch on emp_id=manager_id;
```

### subquery子查询

```sql
-- 1.找出研发部门的经理名字
select name from employee 
where emp_id=(select manager_id from branch where branch_name='研发');
-- 2.找出客户销售金额超过5万的员工名字
# 因为搜寻结果不止一个，所以不能用=，要用in
select name from employee 
where emp_id in (select emp_id from works_with where total_sales>50000);
```

### on delete是什么意思

```sql
# Branch
create table branch(
		`branch_id` int primary key,
		`branch_name` varchar(20),
		`manager_id` int,
		foreign key(`manager_id`) references `employee`(`emp_id`) on delete set null # 设置外键
		
);
```

![image-20230921104358397](file://C:\Users\19851\AppData\Roaming\Typora\typora-user-images\image-20230921104358397.png?lastModify=1695283385)



我们有在设置外键的时候使用到on delete set null，这个是什么意思呢？

举个例子，研发部门的manager_id是206，对应着employee里面的小黄，如果小黄某一天离职了，公司会把他的资料删掉。如果删掉了小黄的资料，那branch里面的206对应着谁呢？所以我们设置on delete set null的意思就是如果emp_id被删掉了，就自动把manager_id设置为NULL

**注意：主键不能被设置为on delete set null**

```sql
# Works_With
create table works_with(
		emp_id int,
		client_id int,
		total_sales int,
		primary key(emp_id, client_id),
		foreign key(emp_id) references employee(emp_id) on delete cascade,
		foreign key(client_id) references client(client_id) on delete cascade
);
```

那这个on delete cascade是什么意思呢？

还是上面哪个例子，假如emp_id里面的206，即小黄离职了，则works_with里面的emp_id对应的那一条数据也会跟着被删除

## 数据库里面的数据类型

1. **整数类型（Integer Types）**：
   - `INT`：整数类型，通常用于存储整数数据。
   - `TINYINT`、`SMALLINT`、`MEDIUMINT`、`BIGINT`：不同大小的整数类型。
2. **浮点数和定点数类型（Floating-Point and Fixed-Point Types）**：
   - `FLOAT`、`DOUBLE`、`REAL`：用于存储浮点数。
   - `DECIMAL`、`NUMERIC`：用于存储精确的定点数，通常用于财务数据。
3. **字符串类型（String Types）**：
   - `CHAR`：固定长度的字符。
   - `VARCHAR`：可变长度的字符。
   - `TEXT`、`LONGTEXT`：用于存储大段文本数据。
4. **日期和时间类型（Date and Time Types）**：
   - `DATE`：日期。
   - `TIME`：时间。
   - `DATETIME`：日期和时间。
   - `TIMESTAMP`：时间戳，通常用于记录最后修改时间。
5. **布尔类型（Boolean Types）**：
   - `BOOLEAN`、`BOOL`：用于存储布尔值（真或假）。
6. **枚举和集合类型（Enumeration and Set Types）**：
   - `ENUM`：用于存储枚举值，只能选择其中一个值。
   - `SET`：用于存储一个或多个集合值。
7. **二进制类型（Binary Types）**：
   - `BLOB`、`MEDIUMBLOB`、`LONGBLOB`：用于存储二进制数据，如图像或文件。
8. **空值类型（NULL Type）**：
   - `NULL`：表示缺少值或未知值。
9. **自动增量类型（Auto-Increment Type）**：
   - `AUTO_INCREMENT`：通常用于创建主键，每次插入新行时，自动递增其值。



## mysql补充

### NULL值处理

当使用select查询表中的数据时，如果提供的查询条件字段为NULL，该命令就无法正常工作。

为了处理这种情况，mysql提供了三大运算符：

- is null：当列的值是null，返回true
- is not null：当列的值不是null，返回true
- <=>：比较操作符，当比较的两个值相等或者都为null时返回true

```sql
# 错误示范
SELECT * FROM runoob_test_tbl WHERE runoob_count = NULL;
SELECT * FROM runoob_test_tbl WHERE runoob_count != NULL;
```

在上述代码中，使用=和！=运算符不起作用。

如果要查询表中数据是否为null，必须使用is null和is not null

```sql
SELECT * FROM runoob_test_tbl WHERE runoob_count IS NULL;
SELECT * from runoob_test_tbl WHERE runoob_count IS NOT NULL;
```

### 正则表达式

| 模式       | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| ^          | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。 |
| $          | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。 |
| .          | 匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像 '[.\n]' 的模式。 |
| [...]      | 字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。 |
| [^...]     | 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'。 |
| p1\|p2\|p3 | 匹配 p1 或 p2 或 p3。例如，'z\|food' 能匹配 "z" 或 "food"。'(z\|f)ood' 则匹配 "zood" 或 "food"。 |
| *          | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| +          | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| {n}        | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,m}      | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。 |

**实例**：

查找name字段中以'st'为开头的所有数据：

```sql
SELECT name FROM person_tbl WHERE name REGEXP '^st';
```

查找name字段中以'ok'为结尾的所有数据：

```sql
SELECT name FROM person_tbl WHERE name REGEXP 'ok$';
```

查找name字段中包含'mar'字符串的所有数据：

```sql
SELECT name FROM person_tbl WHERE name REGEXP 'mar';
```

查找name字段中以元音字符开头或以'ok'字符串结尾的所有数据：

```sql
SELECT name FROM person_tbl WHERE name REGEXP '^[aeiou]|ok$';
```

1、^ 查询以field开头的字符串

```sql
SELECT *
FROM customers 
WHERE last_name REGEXP '^field'
```

2、$ 查询以field结尾的字符串

```sql
SELECT *
FROM customers 
WHERE last_name REGEXP 'field$'
```

3、| 查询含有field或mac或rose结尾的字符串

```sql
SELECT *
FROM customers 
WHERE last_name REGEXP 'field|mac|rose'
```

4、$ , | 查询以field结尾或以mac结尾或含有rose的字符串

```sql
SELECT *
FROM customers 
WHERE last_name REGEXP 'field$|mac$|rose'
```

5、[ ] 查询含有‘ge’或‘ie’或‘me’的字符串

```sql
SELECT *
FROM customers 
WHERE last_name REGEXP '[gim]e'
```

6、[ ] 查询含有’a-h’中的字母加上’e’的字符串

```sql
SELECT *
FROM customers 
WHERE last_name REGEXP '[a-h]e'
```

### mysql事务

mysql事务主要用于处理操作量大，复杂度高的数据。

比如说，在人员管理系统中，如果删除一个人，我需要删除他的基本资料之外，还要删除和该人员有关的信息，比如信箱、文章等等，这样，这些数据库操作语句就构成一个事务。

- 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。
- 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。
- 事务用来管理 insert,update,delete 语句

事务必须满足4个条件（ACID）：

- 原子性（**A**tomicity，或称不可分割性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- 一致性（**C**onsistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作
- 隔离性（**I**solation，又称独立性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，**包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）**
- 持久性（**D**urability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失

**对四个隔离原则进行解释**

- 读未提交( Read Uncommitted )：读未提交是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。
- 读已提交( Read Committed )：在 Read Committed 隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。
- 可重复读( Repeatable Read )：在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。
- 可串行化( Serializable )：Serializable 是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。

虽然 Serializable 隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以**效率会大大下降**，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。
默认隔离级别：如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用 InnoDB，默认的隔离级别是Repeatable Read（可重复读）

**事务控制语句**：

- BEGIN 或 START TRANSACTION 显式地开启一个事务；
- COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；
- ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；
- SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；
- RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；
- ROLLBACK TO identifier 把事务回滚到标记点；
- SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。

**mysql事务处理主要有两种方法：**

mysql中事务默认是隐式事务，执行insert、update、delete操作的时候，数据库自动开启事务、提交或回滚事务。

是否开启隐式事务是由变量autocommit控制的。

所以事务分为**隐式事务**和**显式事务**。

1、用 BEGIN, ROLLBACK, COMMIT来实现

- **BEGIN** 开始一个事务
- **ROLLBACK** 事务回滚
- **COMMIT** 事务确认

2、直接用 SET 来改变 MySQL 的自动提交模式:

- **SET AUTOCOMMIT=0** 禁止自动提交
- **SET AUTOCOMMIT=1** 开启自动提交

**事务只读操作：**

表示在事务中执行的是一些只读操作，如查询，但是不会做insert、update、delete操作，数据库内部对只读事务可能会有一些性能上的优化，用法如下:`begin read only;`只读事务中使用insert、update、delete会报错

**事务中的一些问题（重点）**

这些问题主要是基于数据在多个事务中的可见性来说的。也是并发事务产生的问题

**更新丢失**

丢失更新就是两个不同的事务在某一时刻对同一数据进行读取后，先后进行修改。导致第一次操作数据丢失。

第一类丢失更新 ：A，B 事务同时操作同一数据，A先对改数据进行了更改，B再次更改时失败然后回滚，**把A更新的数据也回滚了**。（事务撤销造成的撤销丢失）

第二类丢失更新：A，B 事务同时操作同一数据，A先对改数据进行了更改，B再次更改并且提交，**把A提交的数据给覆盖了**。（事务提交造成的覆盖丢失）
**脏读**
一个事务在执行的过程中读取到了其他事务还没有提交的数据。

两个事务同时操作同一数据，A事务对该数据进行了修改还没提交的时候，B事务访问了该条事务，并且使用了该数据，此时A事务回滚，那么B事务读到的就是脏数据。

比如事务1，修改了某个数据      事务2，刚好访问了事务1修改后的数据

此时事务1，回滚了操作             事务2，读到还是回滚前的数据

**读已提交**
一个事务操作过程中可以读取到其他事务已经提交的数据。

事务中的每次读取操作，读取到的都是数据库中其他事务已提交的最新的数据（相当于当前读）

**不可重复读**
在同一事务中，多次读取同一数据返回的结果有所不同，换句话说，后续读取可以读到另一事务已提交的更新数据。相反，“可重复读” 在同一事务中多次读取数据时, 能够保证所读数据一样, 也就是后续读取不能读到另一事务已提交的更新数据。

这种情况发生 在一个事务内多次读同一数据。A事务查询某条数据，该事务未结束时，B事务也访问同一数据并进行了修改。那么在A事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。

事务1，查询某个数据 事务2，修改了某个数据，提交

事务1，再次查询这个数据

这样事务1两次查询的数据不一样，称为不可重复读

**可重复读**
一个事务操作中对于一个读取操作不管多少次，读取到的结果都是一样的。

**幻读**
脏读、不可重复读、可重复读、幻读，其中最难理解的是幻读

以mysql为例：

- 幻读现象例子：
  - 可重复读模式下，比如有个用户表，手机号码为主键，有两个事物进行如下操作
  - 事务A操作如下： 1、打开事务 2、查询号码为X的记录，不存在 3、插入号码为X的数据，插入报错（为什么会报错，先向下看） 4、查询号码为X的记录，发现还是不存在（由于是可重复读，所以读取记录X还是不存在的）
  - 事物B操作：在事务A第2步操作时插入了一条X的记录，所以会导致A中第3步插入报错（违反了唯一约束）
  - 上面操作对A来说就像发生了幻觉一样，明明查询X（A中第二步、第四步）不存在，但却无法插入成功
  - 幻读可以这么理解：事务中后面的操作（插入号码X）需要上面的读取操作（查询号码X的记录）提供支持，但读取操作却不能支持下面的操作时产生的错误，就像发生了幻觉一样。

- 看第二种解释：
  - 事务A在操作一堆数据的时候，事务B插入了一条数据，A事务再次（第二次）查询，发现多了一条数据，像是幻觉。与不可重复读类似，不同的是一个是修改删除操作，一个是新增操作。



#### MySQL事务的可串行化是什么意思？

事务有4个特性：原子性、一致性、隔离性、持久性。数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，**包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）**

**举个串行化的例子：**

此时有a、b两个账户，设置b账户的隔离级别，设置为Serializable（串行化）。

此时b账户开启一个事务，查询各个账户的余额，a账户开启一个事务，在事务中执行插入操作

结果：当b账户正在事务中查询余额信息时，a账户中的操作是不可以立即执行的

b账户执行完查询余额，提交当前事务

在b账户事务提交之后，a账户中的添加操作才能执行成功

**Conclusion：可以看出，如果一个事务，使用了SERIALIZABLE——可串行化隔离级别时，在这个事务没有被提交之前
其他的线程，只能等到当前操作完成之后，才能进行操作，这样会非常耗时，而且，影响数据库的性能，通常情况下，不会使用这种隔离级别**

### alter命令

alter命令用于修改数据库、表和索引等对象的结构

alter命令非常强大，允许你添加、修改或删除数据库对象，并且可以用于更改表的列定义、添加约束、创建和删除索引等操作

alter用在外面写，并不是在新建某表的时候用

**修改表结构**

添加新列：`alter table t_name add column_name data_type;`

修改列定义：`alter table t_name modify column_name new_data_type;`

修改列名称：`alter table t_name change old_column_name new_column_name data_type;`

删除列：`alter table t_name drop column_name;`

**添加约束**

添加主键：`alter table t_name add primary key(column_name);`

添加外键：`alter table t_name add foreign key(column_name) references referenced_table(ref_column_name);`

添加唯一约束：`alter table t_name add constraint constraint_name unique(column_name);`添加唯一约束的列中有重复的值时会添加约束失败，这时把重复的值删除就可以了

**创建索引**

创建普通索引：`alter table t_name add index index_name(column1 [ASC|DESC], column2 [ASC|DESC], ...);`

创建唯一索引：`alter table t_name add unique index index_name(column1 [ASC|DESC], column2 [ASC|DESC], ...);`

删除索引：`alter table t_name drop index index_name`

重命名表：`alter table old_table_name rename to new_old_name;`

### mysql索引

MySQL 索引是一种数据结构，用于加快数据库查询的速度和性能。

MySQL 索引的建立对于 MySQL 的高效运行是很重要的，索引可以大大提高 MySQL 的检索速度。

> MySQL 索引类似于书籍的索引，通过存储指向数据行的指针，可以快速定位和访问表中的特定数据。

索引分单列索引和组合索引：

- 单列索引，即一个索引只包含单个列，一个表可以有多个单列索引。
- 组合索引，即一个索引包含多个列。

创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。

实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。

索引虽然能够提高查询性能，但也需要注意以下几点：

- 索引需要占用额外的存储空间。
- 对表进行插入、更新和删除操作时，索引需要维护，可能会影响性能。
- 过多或不合理的索引可能会导致性能下降，因此需要谨慎选择和规划索引。

#### 普通索引

索引能够显著提高查询的速度，尤其是在大型表中进行搜索时。通过使用索引，MySQL 可以直接定位到满足查询条件的数据行，而无需逐行扫描整个表

使用`create index`创建普通索引，

语法为：`create index index_name on table_name(column1 [ASC|DESC], column2 [ASC|DESC], ...);`

(column1, column2, ...): 指定要索引的表列名。你可以指定一个或多个列作为索引的组合。这些列的数据类型通常是数值、文本或日期。
ASC和DESC（可选）: 用于指定索引的排序顺序。默认情况下，索引以升序（ASC）排序。

我们可以使用**alter table**在已有的表中创建索引：`alter table t_name add index index_name(column1 [ASC|DESC], column2 [ASC|DESC], ...);`

也可以直接在**创建表的时候直接指定**：

```sql
CREATE TABLE table_name (
  column1 data_type,
  column2 data_type,
  ...,
  INDEX index_name (column1 [ASC|DESC], column2 [ASC|DESC], ...)
);
```

**删除索引**

直接删除：`drop index index_name on table_name;`

使用alter table语句删除索引：`alter table table_name drop index index_name;`

两个都可以使用

如果索引不存在，执行命令会报错。因此在删除索引之前最好确认该索引是否存在，或者使用错误处理机制来处理可能的错误情况。

**唯一索引**

在普通索引的基础上加一个unique

创建索引：`create unique index index_name on table_name(column1 [ASC|DESC], column2 [ASC|DESC], ...);`

还可以使用`alter table`来创建唯一索引：`alter table t_name add unique index index_name(column1 [ASC|DESC], column2 [ASC|DESC], ...);`

**显示索引信息**：`show index from table_name\G`

\G代表格式化输出信息

### mysql临时表

MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间

当我们需要使用难以接受的或开销很大的一个SELECT语句和JOIN子句的数据时，临时表非常方便。

创建临时表，增加了temporary关键字表示临时表

```sql
create temporary table t_name(
    ...
    ...
);
```

创建结构基于现有表的临时表

```sql
create temporary table temp_t_name
select * from original_table
limit 0;
```

实例：（没看懂，用的应该不多）

```sql
//下面的示例创建一个临时表，该表按收入存储前10名客户。临时表的结构是从以下SELECT语句派生的：
CREATE TEMPORARY TABLE top_customers
SELECT p.customerNumber, 
       c.customerName, 
       ROUND(SUM(p.amount),2) sales
FROM payments p
INNER JOIN customers c ON c.customerNumber = p.customerNumber
GROUP BY p.customerNumber
ORDER BY sales DESC
LIMIT 10;
//从top_customers临时表中查询数据，就像从永久表中查询一样：
SELECT 
    customerNumber, 
    customerName, 
    sales
FROM
    top_customers
ORDER BY sales;

```

删除

可以通过DROP TABLE语句删除临时表，但不推荐这样，因为当临时表与永久表同名时，有可能会误删永久表

`drop temporary table t_name;`

**注意**

1. 当会话结束或连接终止时，MySQL自动删除临时表。当然，您可以在`drop temporary table`不再使用临时表时使用该 语句显式删除该临时表。
2. 临时表仅对创建它的客户端可用并且可以访问。不同的客户端可以创建具有相同名称的临时表而不会导致错误，因为只有创建临时表的客户端才能看到它。但是，在同一会话中，两个临时表不能共享相同的名称。
3. 临时表可以与数据库中的普通表具有相同的名称。例如，如果您创建一个employees在示例数据库中命名的临时表，则现有employees表将变得不可访问。您针对该employees表发出的每个查询现在都引用该临时表 employees。当您删除employees临时表时，永久employees表可用且可访问

### mysql复制表

如果我们需要完全的复制MySQL的数据表，包括表的结构，索引，默认值等。 如果仅仅使用**CREATE TABLE ... SELECT** 命令，是无法实现的

具体实现步骤：

- 使用show create table命令获取创建数据表（create table）语句，该语句包含了原数据表的结构，索引等。
- 复制一下命令显示的sql语句，修改数据名，并执行sql语句，通过以上命令将完全的复制数据表结构
- 如果你想复制表的内容，你就可以使用insert into...select语句来实现

**复制表的三种方式**

`create table t_name_new as (select * from t_name_old);`这个语句只是把select语句的结果建一个表，所以新表不会有主键，索引。



如果只复制表结构：

`create table t_name_new as select * from t_name_old where 1=2;`或者`create table t_name_new like t_name_old;`

前一种方式是不会复制主键类型，索引的。而后一种方式是把旧表的所有字段类型都复制到新表



只复制表数据：

如果两个表结构一样：`insert into t_name_new select * from t_name_old;`

如果两个表结构不一样：`insert into t_name_new(column1,column2...) select column1,column2... from t_name_old;`

### mysql序列使用

MySQL 序列是一组整数：1, 2, 3, ...，由于一张数据表只能有一个字段自增主键， 如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现

最简单使用序列的方法是使用`auto_increment`来定义序列

```sql
create table t_name(
	id int unsigned not null auto_increment,
	...
);
```

### 处理重复数据

**防止重复数据出现**：我们可以在表中设置指定的字段为**primary key或者unique**来保证数据的唯一性

**统计重复数据**：

```sql
SELECT COUNT(*) as repetitions, last_name, first_name
FROM person_tbl
GROUP BY last_name, first_name
HAVING repetitions > 1;
```

**过滤重复数据**：如果需要读取不重复的数据可以在select语句中使用**distinct**关键字来过滤重复数据

`select distinct last_name, first_name from person_t1;`

我们也可以使用group by来读取数据表中不重复的数据：

`select last_name, first_name from person_t1 group by (last_name, first_name);`

**删除重复数据**：

如果你想删除数据表中的重复数据，你可以使用以下的SQL语句：

```sql
mysql> CREATE TABLE tmp SELECT last_name, first_name, sex FROM person_tbl  GROUP BY (last_name, first_name, sex);
mysql> DROP TABLE person_tbl;
mysql> ALTER TABLE tmp RENAME TO person_tbl;
```

当然你也可以在数据表中添加 INDEX（索引） 和 PRIMAY KEY（主键）这种简单的方法来删除表中的重复记录。方法如下：

```sql
mysql> ALTER IGNORE TABLE person_tbl
    -> ADD PRIMARY KEY (last_name, first_name);
```

### sql注入

如果您通过网页获取用户输入的数据并将其插入一个MySQL数据库，那么就有可能发生SQL注入安全的问题

所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

我们永远不要信任用户的输入，我们必须认定用户输入的数据都是不安全的，我们都需要对用户输入的数据进行过滤处理

**防止sql注入**：（自己百度）

**like语句的注入**：like查询时，如果用户输入的值有"_"和"%"，则会出现这种情况：用户本来只是想查询"abcd_"，查询结果中却有"abcd_"、"abcde"、"abcdf"等等；用户要查询"30%"（注：百分之三十）时也会出现问题**（解决方法自己百度）**

### 导出数据(不重要)

MySQL中你可以使用**SELECT...INTO OUTFILE**语句来简单的导出数据到文本文件上

**使用select...into outfile语句导出数据**

我们将数据表 runoob_tbl 数据导出到 /tmp/runoob.txt 文件中：`select * from runoob_tbl into outfile '/tmp/runoob.txt';`

在下面的例子中，生成一个文件，各值用逗号隔开。这种格式可以被许多程序使用

```sql
select a,b,a+b into outfile '/tmp/result.txt' 
fields terminated by ',' optionally enclosed by '"'
lines terminated by '\n'
from test_table;
```

### 导入数据(不重要)

### mysql函数

mysql有很多内置的函数

#### mysql字符串函数

| 函数                                  | 描述                                                         | 实例                                                         |
| :------------------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| ASCII(s)                              | 返回字符串 s 的第一个字符的 ASCII 码。                       | 返回 CustomerName 字段第一个字母的 ASCII 码：`SELECT ASCII(CustomerName) AS NumCodeOfFirstChar FROM Customers;` |
| CHAR_LENGTH(s)                        | 返回字符串 s 的字符数                                        | 返回字符串 RUNOOB 的字符数`SELECT CHAR_LENGTH("RUNOOB") AS LengthOfString;` |
| CHARACTER_LENGTH(s)                   | 返回字符串 s 的字符数，等同于 CHAR_LENGTH(s)                 | 返回字符串 RUNOOB 的字符数`SELECT CHARACTER_LENGTH("RUNOOB") AS LengthOfString;` |
| CONCAT(s1,s2...sn)                    | 字符串 s1,s2 等多个字符串合并为一个字符串                    | 合并多个字符串`SELECT CONCAT("SQL ", "Runoob ", "Gooogle ", "Facebook") AS ConcatenatedString;` |
| CONCAT_WS(x, s1,s2...sn)              | 同 CONCAT(s1,s2,...) 函数，但是每个字符串之间要加上 x，x 可以是分隔符 | 合并多个字符串，并添加分隔符：`SELECT CONCAT_WS("-", "SQL", "Tutorial", "is", "fun!")AS ConcatenatedString;` |
| FIELD(s,s1,s2...)                     | 返回第一个字符串 s 在字符串列表(s1,s2...)中的位置            | 返回字符串 c 在列表值中的位置：`SELECT FIELD("c", "a", "b", "c", "d", "e");` |
| FIND_IN_SET(s1,s2)                    | 返回在字符串s2中与s1匹配的字符串的位置                       | 返回字符串 c 在指定字符串中的位置：`SELECT FIND_IN_SET("c", "a,b,c,d,e");` |
| FORMAT(x,n)                           | 函数可以将数字 x 进行格式化 "#,###.##", 将 x 保留到小数点后 n 位，最后一位四舍五入。 | 格式化数字 "#,###.##" 形式：`SELECT FORMAT(250500.5634, 2);     -- 输出 250,500.56` |
| INSERT(s1,x,len,s2)                   | 字符串 s2 替换 s1 的 x 位置开始长度为 len 的字符串           | 从字符串第一个位置开始的 6 个字符替换为 runoob：`SELECT INSERT("google.com", 1, 6, "runoob");  -- 输出：runoob.com` |
| LOCATE(s1,s)                          | 从字符串 s 中获取 s1 的开始位置                              | 获取 b 在字符串 abc 中的位置：`SELECT LOCATE('st','myteststring');  -- 5`返回字符串 abc 中 b 的位置：`SELECT LOCATE('b', 'abc') -- 2` |
| LCASE(s)                              | 将字符串 s 的所有字母变成小写字母                            | 字符串 RUNOOB 转换为小写：`SELECT LCASE('RUNOOB') -- runoob` |
| LEFT(s,n)                             | 返回字符串 s 的前 n 个字符                                   | 返回字符串 runoob 中的前两个字符：`SELECT LEFT('runoob',2) -- ru` |
| LOWER(s)                              | 将字符串 s 的所有字母变成小写字母                            | 字符串 RUNOOB 转换为小写：`SELECT LOWER('RUNOOB') -- runoob` |
| LPAD(s1,len,s2)                       | 在字符串 s1 的开始处填充字符串 s2，使字符串长度达到 len      | 将字符串 xx 填充到 abc 字符串的开始处：`SELECT LPAD('abc',5,'xx') -- xxabc` |
| LTRIM(s)                              | 去掉字符串 s 开始处的空格                                    | 去掉字符串 RUNOOB开始处的空格：`SELECT LTRIM("    RUNOOB") AS LeftTrimmedString;-- RUNOOB` |
| MID(s,n,len)                          | 从字符串 s 的 n 位置截取长度为 len 的子字符串，同 SUBSTRING(s,n,len) | 从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：`SELECT MID("RUNOOB", 2, 3) AS ExtractString; -- UNO` |
| POSITION(s1 IN s)                     | 从字符串 s 中获取 s1 的开始位置                              | 返回字符串 abc 中 b 的位置：`SELECT POSITION('b' in 'abc') -- 2` |
| REPEAT(s,n)                           | 将字符串 s 重复 n 次                                         | 将字符串 runoob 重复三次：`SELECT REPEAT('runoob',3) -- runoobrunoobrunoob` |
| REPLACE(s,s1,s2)                      | 将字符串 s2 替代字符串 s 中的字符串 s1                       | 将字符串 abc 中的字符 a 替换为字符 x：`SELECT REPLACE('abc','a','x') --xbc` |
| REVERSE(s)                            | 将字符串s的顺序反过来                                        | 将字符串 abc 的顺序反过来：`SELECT REVERSE('abc') -- cba`    |
| RIGHT(s,n)                            | 返回字符串 s 的后 n 个字符                                   | 返回字符串 runoob 的后两个字符：`SELECT RIGHT('runoob',2) -- ob` |
| RPAD(s1,len,s2)                       | 在字符串 s1 的结尾处添加字符串 s2，使字符串的长度达到 len    | 将字符串 xx 填充到 abc 字符串的结尾处：`SELECT RPAD('abc',5,'xx') -- abcxx` |
| RTRIM(s)                              | 去掉字符串 s 结尾处的空格                                    | 去掉字符串 RUNOOB 的末尾空格：`SELECT RTRIM("RUNOOB     ") AS RightTrimmedString;   -- RUNOOB` |
| SPACE(n)                              | 返回 n 个空格                                                | 返回 10 个空格：`SELECT SPACE(10);`                          |
| STRCMP(s1,s2)                         | 比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1>s2 返回 1，如果 s1<s2 返回 -1 | 比较字符串：`SELECT STRCMP("runoob", "runoob");  -- 0`       |
| SUBSTR(s, start, length)              | 从字符串 s 的 start 位置截取长度为 length 的子字符串         | 从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：`SELECT SUBSTR("RUNOOB", 2, 3) AS ExtractString; -- UNO` |
| SUBSTRING(s, start, length)           | 从字符串 s 的 start 位置截取长度为 length 的子字符串，等同于 SUBSTR(s, start, length) | 从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：`SELECT SUBSTRING("RUNOOB", 2, 3) AS ExtractString; -- UNO` |
| SUBSTRING_INDEX(s, delimiter, number) | 返回从字符串 s 的第 number 个出现的分隔符 delimiter 之后的子串。 如果 number 是正数，返回第 number 个字符左边的字符串。 如果 number 是负数，返回第(number 的绝对值(从右边数))个字符右边的字符串。 | `SELECT SUBSTRING_INDEX('a*b','*',1) -- a SELECT SUBSTRING_INDEX('a*b','*',-1)  -- b SELECT SUBSTRING_INDEX(SUBSTRING_INDEX('a*b*c*d*e','*',3),'*',-1)  -- c` |
| TRIM(s)                               | 去掉字符串 s 开始和结尾处的空格                              | 去掉字符串 RUNOOB 的首尾空格：`SELECT TRIM('    RUNOOB    ') AS TrimmedString;` |
| UCASE(s)                              | 将字符串转换为大写                                           | 将字符串 runoob 转换为大写：`SELECT UCASE("runoob"); -- RUNOOB` |
| UPPER(s)                              | 将字符串转换为大写                                           | 将字符串 runoob 转换为大写：`SELECT UPPER("runoob"); -- RUNOOB` |

#### mysql 数字函数

| 函数名                             | 描述                                                         | 实例                                                         |
| :--------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| ABS(x)                             | 返回 x 的绝对值                                              | 返回 -1 的绝对值：`SELECT ABS(-1) -- 返回1`                  |
| ACOS(x)                            | 求 x 的反余弦值（单位为弧度），x 为一个数值                  | `SELECT ACOS(0.25);`                                         |
| ASIN(x)                            | 求反正弦值（单位为弧度），x 为一个数值                       | `SELECT ASIN(0.25);`                                         |
| ATAN(x)                            | 求反正切值（单位为弧度），x 为一个数值                       | `SELECT ATAN(2.5);`                                          |
| ATAN2(n, m)                        | 求反正切值（单位为弧度）                                     | `SELECT ATAN2(-0.8, 2);`                                     |
| AVG(expression)                    | 返回一个表达式的平均值，expression 是一个字段                | 返回 Products 表中Price 字段的平均值：`SELECT AVG(Price) AS AveragePrice FROM Products;` |
| CEIL(x)                            | 返回大于或等于 x 的最小整数                                  | `SELECT CEIL(1.5) -- 返回2`                                  |
| CEILING(x)                         | 返回大于或等于 x 的最小整数                                  | `SELECT CEILING(1.5); -- 返回2`                              |
| COS(x)                             | 求余弦值(参数是弧度)                                         | `SELECT COS(2);`                                             |
| COT(x)                             | 求余切值(参数是弧度)                                         | `SELECT COT(6);`                                             |
| COUNT(expression)                  | 返回查询的记录总数，expression 参数是一个字段或者 * 号       | 返回 Products 表中 products 字段总共有多少条记录：`SELECT COUNT(ProductID) AS NumberOfProducts FROM Products;` |
| DEGREES(x)                         | 将弧度转换为角度                                             | `SELECT DEGREES(3.1415926535898) -- 180`                     |
| n DIV m                            | 整除，n 为被除数，m 为除数                                   | 计算 10 除于 5：`SELECT 10 DIV 5;  -- 2`                     |
| EXP(x)                             | 返回 e 的 x 次方                                             | 计算 e 的三次方：`SELECT EXP(3) -- 20.085536923188`          |
| FLOOR(x)                           | 返回小于或等于 x 的最大整数                                  | 小于或等于 1.5 的整数：`SELECT FLOOR(1.5) -- 返回1`          |
| GREATEST(expr1, expr2, expr3, ...) | 返回列表中的最大值                                           | 返回以下数字列表中的最大值：`SELECT GREATEST(3, 12, 34, 8, 25); -- 34`返回以下字符串列表中的最大值：`SELECT GREATEST("Google", "Runoob", "Apple");   -- Runoob` |
| LEAST(expr1, expr2, expr3, ...)    | 返回列表中的最小值                                           | 返回以下数字列表中的最小值：`SELECT LEAST(3, 12, 34, 8, 25); -- 3`返回以下字符串列表中的最小值：`SELECT LEAST("Google", "Runoob", "Apple");   -- Apple` |
| LN                                 | 返回数字的自然对数，以 e 为底。                              | 返回 2 的自然对数：`SELECT LN(2);  -- 0.6931471805599453`    |
| LOG(x) 或 LOG(base, x)             | 返回自然对数(以 e 为底的对数)，如果带有 base 参数，则 base 为指定带底数。 | `SELECT LOG(20.085536923188) -- 3 SELECT LOG(2, 4); -- 2`    |
| LOG10(x)                           | 返回以 10 为底的对数                                         | `SELECT LOG10(100) -- 2`                                     |
| LOG2(x)                            | 返回以 2 为底的对数                                          | 返回以 2 为底 6 的对数：`SELECT LOG2(6);  -- 2.584962500721156` |
| MAX(expression)                    | 返回字段 expression 中的最大值                               | 返回数据表 Products 中字段 Price 的最大值：`SELECT MAX(Price) AS LargestPrice FROM Products;` |
| MIN(expression)                    | 返回字段 expression 中的最小值                               | 返回数据表 Products 中字段 Price 的最小值：`SELECT MIN(Price) AS MinPrice FROM Products;` |
| MOD(x,y)                           | 返回 x 除以 y 以后的余数                                     | 5 除于 2 的余数：`SELECT MOD(5,2) -- 1`                      |
| PI()                               | 返回圆周率(3.141593）                                        | `SELECT PI() --3.141593`                                     |
| POW(x,y)                           | 返回 x 的 y 次方                                             | 2 的 3 次方：`SELECT POW(2,3) -- 8`                          |
| POWER(x,y)                         | 返回 x 的 y 次方                                             | 2 的 3 次方：`SELECT POWER(2,3) -- 8`                        |
| RADIANS(x)                         | 将角度转换为弧度                                             | 180 度转换为弧度：`SELECT RADIANS(180) -- 3.1415926535898`   |
| RAND()                             | 返回 0 到 1 的随机数                                         | `SELECT RAND() --0.93099315644334`                           |
| ROUND(x [,y])                      | 返回离 x 最近的整数，可选参数 y 表示要四舍五入的小数位数，如果省略，则返回整数。 | `SELECT ROUND(1.23456) --1 SELECT ROUND(345.156, 2) -- 345.16` |
| SIGN(x)                            | 返回 x 的符号，x 是负数、0、正数分别返回 -1、0 和 1          | `SELECT SIGN(-10) -- (-1)`                                   |
| SIN(x)                             | 求正弦值(参数是弧度)                                         | `SELECT SIN(RADIANS(30)) -- 0.5`                             |
| SQRT(x)                            | 返回x的平方根                                                | 25 的平方根：`SELECT SQRT(25) -- 5`                          |
| SUM(expression)                    | 返回指定字段的总和                                           | 计算 OrderDetails 表中字段 Quantity 的总和：`SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails;` |
| TAN(x)                             | 求正切值(参数是弧度)                                         | `SELECT TAN(1.75);  -- -5.52037992250933`                    |
| TRUNCATE(x,y)                      | 返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是不会进行四舍五入） | `SELECT TRUNCATE(1.23456,3) -- 1.234`                        |

#### mysql日期函数

| 函数名                                            | 描述                                                         | 实例                                                         |
| :------------------------------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| ADDDATE(d,n)                                      | 计算起始日期 d 加上 n 天的日期                               | `SELECT ADDDATE("2017-06-15", INTERVAL 10 DAY); ->2017-06-25` |
| ADDTIME(t,n)                                      | n 是一个时间表达式，时间 t 加上时间表达式 n                  | 加 5 秒：`SELECT ADDTIME('2011-11-11 11:11:11', 5); ->2011-11-11 11:11:16 (秒)`添加 2 小时, 10 分钟, 5 秒:`SELECT ADDTIME("2020-06-15 09:34:21", "2:10:5");  -> 2020-06-15 11:44:26` |
| CURDATE()                                         | 返回当前日期                                                 | `SELECT CURDATE(); -> 2018-09-19`                            |
| CURRENT_DATE()                                    | 返回当前日期                                                 | `SELECT CURRENT_DATE(); -> 2018-09-19`                       |
| CURRENT_TIME                                      | 返回当前时间                                                 | `SELECT CURRENT_TIME(); -> 19:59:02`                         |
| CURRENT_TIMESTAMP()                               | 返回当前日期和时间                                           | `SELECT CURRENT_TIMESTAMP() -> 2018-09-19 20:57:43`          |
| CURTIME()                                         | 返回当前时间                                                 | `SELECT CURTIME(); -> 19:59:02`                              |
| DATE()                                            | 从日期或日期时间表达式中提取日期值                           | `SELECT DATE("2017-06-15");     -> 2017-06-15`               |
| DATEDIFF(d1,d2)                                   | 计算日期 d1->d2 之间相隔的天数                               | `SELECT DATEDIFF('2001-01-01','2001-02-02') -> -32`          |
| DATE_ADD(d，INTERVAL expr type)                   | 计算起始日期 d 加上一个时间段后的日期，type 值可以是：MICROSECONDSECONDMINUTEHOURDAYWEEKMONTHQUARTERYEARSECOND_MICROSECONDMINUTE_MICROSECONDMINUTE_SECONDHOUR_MICROSECONDHOUR_SECONDHOUR_MINUTEDAY_MICROSECONDDAY_SECONDDAY_MINUTEDAY_HOURYEAR_MONTH | `SELECT DATE_ADD("2017-06-15", INTERVAL 10 DAY);     -> 2017-06-25 SELECT DATE_ADD("2017-06-15 09:34:21", INTERVAL 15 MINUTE); -> 2017-06-15 09:49:21 SELECT DATE_ADD("2017-06-15 09:34:21", INTERVAL -3 HOUR); ->2017-06-15 06:34:21 SELECT DATE_ADD("2017-06-15 09:34:21", INTERVAL -3 MONTH); ->2017-04-15` |
| DATE_FORMAT(d,f)                                  | 按表达式 f的要求显示日期 d                                   | `SELECT DATE_FORMAT('2011-11-11 11:11:11','%Y-%m-%d %r') -> 2011-11-11 11:11:11 AM` |
| DATE_SUB(date,INTERVAL expr type)                 | 函数从日期减去指定的时间间隔。                               | Orders 表中 OrderDate 字段减去 2 天：`SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 2 DAY) AS OrderPayDate FROM Orders` |
| DAY(d)                                            | 返回日期值 d 的日期部分                                      | `SELECT DAY("2017-06-15");   -> 15`                          |
| DAYNAME(d)                                        | 返回日期 d 是星期几，如 Monday,Tuesday                       | `SELECT DAYNAME('2011-11-11 11:11:11') ->Friday`             |
| DAYOFMONTH(d)                                     | 计算日期 d 是本月的第几天                                    | `SELECT DAYOFMONTH('2011-11-11 11:11:11') ->11`              |
| DAYOFWEEK(d)                                      | 日期 d 今天是星期几，1 星期日，2 星期一，以此类推            | `SELECT DAYOFWEEK('2011-11-11 11:11:11') ->6`                |
| DAYOFYEAR(d)                                      | 计算日期 d 是本年的第几天                                    | `SELECT DAYOFYEAR('2011-11-11 11:11:11') ->315`              |
| EXTRACT(type FROM d)                              | 从日期 d 中获取指定的值，type 指定返回的值。 type可取值为： MICROSECONDSECONDMINUTEHOURDAYWEEKMONTHQUARTERYEARSECOND_MICROSECONDMINUTE_MICROSECONDMINUTE_SECONDHOUR_MICROSECONDHOUR_SECONDHOUR_MINUTEDAY_MICROSECONDDAY_SECONDDAY_MINUTEDAY_HOURYEAR_MONTH | `SELECT EXTRACT(MINUTE FROM '2011-11-11 11:11:11')  -> 11`   |
| FROM_DAYS(n)                                      | 计算从 0000 年 1 月 1 日开始 n 天后的日期                    | `SELECT FROM_DAYS(1111) -> 0003-01-16`                       |
| HOUR(t)                                           | 返回 t 中的小时值                                            | `SELECT HOUR('1:2:3') -> 1`                                  |
| LAST_DAY(d)                                       | 返回给给定日期的那一月份的最后一天                           | `SELECT LAST_DAY("2017-06-20"); -> 2017-06-30`               |
| LOCALTIME()                                       | 返回当前日期和时间                                           | `SELECT LOCALTIME() -> 2018-09-19 20:57:43`                  |
| LOCALTIMESTAMP()                                  | 返回当前日期和时间                                           | `SELECT LOCALTIMESTAMP() -> 2018-09-19 20:57:43`             |
| MAKEDATE(year, day-of-year)                       | 基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期 | `SELECT MAKEDATE(2017, 3); -> 2017-01-03`                    |
| MAKETIME(hour, minute, second)                    | 组合时间，参数分别为小时、分钟、秒                           | `SELECT MAKETIME(11, 35, 4); -> 11:35:04`                    |
| MICROSECOND(date)                                 | 返回日期参数所对应的微秒数                                   | `SELECT MICROSECOND("2017-06-20 09:34:00.000023"); -> 23`    |
| MINUTE(t)                                         | 返回 t 中的分钟值                                            | `SELECT MINUTE('1:2:3') -> 2`                                |
| MONTHNAME(d)                                      | 返回日期当中的月份名称，如 November                          | `SELECT MONTHNAME('2011-11-11 11:11:11') -> November`        |
| MONTH(d)                                          | 返回日期d中的月份值，1 到 12                                 | `SELECT MONTH('2011-11-11 11:11:11') ->11`                   |
| NOW()                                             | 返回当前日期和时间                                           | `SELECT NOW() -> 2018-09-19 20:57:43`                        |
| PERIOD_ADD(period, number)                        | 为 年-月 组合日期添加一个时段                                | `SELECT PERIOD_ADD(201703, 5);    -> 201708`                 |
| PERIOD_DIFF(period1, period2)                     | 返回两个时段之间的月份差值                                   | `SELECT PERIOD_DIFF(201710, 201703); -> 7`                   |
| QUARTER(d)                                        | 返回日期d是第几季节，返回 1 到 4                             | `SELECT QUARTER('2011-11-11 11:11:11') -> 4`                 |
| SECOND(t)                                         | 返回 t 中的秒钟值                                            | `SELECT SECOND('1:2:3') -> 3`                                |
| SEC_TO_TIME(s)                                    | 将以秒为单位的时间 s 转换为时分秒的格式                      | `SELECT SEC_TO_TIME(4320) -> 01:12:00`                       |
| STR_TO_DATE(string, format_mask)                  | 将字符串转变为日期                                           | `SELECT STR_TO_DATE("August 10 2017", "%M %d %Y"); -> 2017-08-10` |
| SUBDATE(d,n)                                      | 日期 d 减去 n 天后的日期                                     | `SELECT SUBDATE('2011-11-11 11:11:11', 1) ->2011-11-10 11:11:11 (默认是天)` |
| SUBTIME(t,n)                                      | 时间 t 减去 n 秒的时间                                       | `SELECT SUBTIME('2011-11-11 11:11:11', 5) ->2011-11-11 11:11:06 (秒)` |
| SYSDATE()                                         | 返回当前日期和时间                                           | `SELECT SYSDATE() -> 2018-09-19 20:57:43`                    |
| TIME(expression)                                  | 提取传入表达式的时间部分                                     | `SELECT TIME("19:30:10"); -> 19:30:10`                       |
| TIME_FORMAT(t,f)                                  | 按表达式 f 的要求显示时间 t                                  | `SELECT TIME_FORMAT('11:11:11','%r') 11:11:11 AM`            |
| TIME_TO_SEC(t)                                    | 将时间 t 转换为秒                                            | `SELECT TIME_TO_SEC('1:12:00') -> 4320`                      |
| TIMEDIFF(time1, time2)                            | 计算时间差值                                                 | `mysql> SELECT TIMEDIFF("13:10:11", "13:10:10"); -> 00:00:01 mysql> SELECT TIMEDIFF('2000:01:01 00:00:00',    ->                 '2000:01:01 00:00:00.000001');        -> '-00:00:00.000001' mysql> SELECT TIMEDIFF('2008-12-31 23:59:59.000001',    ->                 '2008-12-30 01:01:01.000002');        -> '46:58:57.999999'` |
| TIMESTAMP(expression, interval)                   | 单个参数时，函数返回日期或日期时间表达式；有2个参数时，将参数加和 | `mysql> SELECT TIMESTAMP("2017-07-23",  "13:10:11"); -> 2017-07-23 13:10:11 mysql> SELECT TIMESTAMP('2003-12-31');        -> '2003-12-31 00:00:00' mysql> SELECT TIMESTAMP('2003-12-31 12:00:00','12:00:00');        -> '2004-01-01 00:00:00'` |
| TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2) | 计算时间差，返回 datetime_expr2 − datetime_expr1 的时间差    | `mysql> SELECT TIMESTAMPDIFF(DAY,'2003-02-01','2003-05-01');   // 计算两个时间相隔多少天        -> 89 mysql> SELECT TIMESTAMPDIFF(MONTH,'2003-02-01','2003-05-01');   // 计算两个时间相隔多少月        -> 3 mysql> SELECT TIMESTAMPDIFF(YEAR,'2002-05-01','2001-01-01');    // 计算两个时间相隔多少年        -> -1 mysql> SELECT TIMESTAMPDIFF(MINUTE,'2003-02-01','2003-05-01 12:05:55');  // 计算两个时间相隔多少分钟        -> 128885` |
| TO_DAYS(d)                                        | 计算日期 d 距离 0000 年 1 月 1 日的天数                      | `SELECT TO_DAYS('0001-01-01 01:01:01') -> 366`               |
| WEEK(d)                                           | 计算日期 d 是本年的第几个星期，范围是 0 到 53                | `SELECT WEEK('2011-11-11 11:11:11') -> 45`                   |
| WEEKDAY(d)                                        | 日期 d 是星期几，0 表示星期一，1 表示星期二                  | `SELECT WEEKDAY("2017-06-15"); -> 3`                         |
| WEEKOFYEAR(d)                                     | 计算日期 d 是本年的第几个星期，范围是 0 到 53                | `SELECT WEEKOFYEAR('2011-11-11 11:11:11') -> 45`             |
| YEAR(d)                                           | 返回年份                                                     | `SELECT YEAR("2017-06-15"); -> 2017`                         |
| YEARWEEK(date, mode)                              | 返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推 | `SELECT YEARWEEK("2017-06-15"); -> 201724`                   |

#### mysql高级函数

| 函数名                                                       | 描述                                                         | 实例                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| BIN(x)                                                       | 返回 x 的二进制编码                                          | 15 的 2 进制编码:`SELECT BIN(15); -- 1111`                   |
| BINARY(s)                                                    | 将字符串 s 转换为二进制字符串                                | `SELECT BINARY "RUNOOB"; -> RUNOOB`                          |
| `CASE expression    WHEN condition1 THEN result1    WHEN condition2 THEN result2   ...    WHEN conditionN THEN resultN    ELSE result END` | CASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1, 如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了。 | `SELECT CASE  　WHEN 1 > 0 　THEN '1 > 0' 　WHEN 2 > 0 　THEN '2 > 0' 　ELSE '3 > 0' 　END ->1 > 0` |
| CAST(x AS type)                                              | 转换数据类型                                                 | 字符串日期转换为日期：`SELECT CAST("2017-08-29" AS DATE); -> 2017-08-29` |
| COALESCE(expr1, expr2, ...., expr_n)                         | 返回参数中的第一个非空表达式（从左向右）                     | `SELECT COALESCE(NULL, NULL, NULL, 'runoob.com', NULL, 'google.com'); -> runoob.com` |
| CONNECTION_ID()                                              | 返回唯一的连接 ID                                            | `SELECT CONNECTION_ID(); -> 4292835`                         |
| CONV(x,f1,f2)                                                | 返回 f1 进制数变成 f2 进制数                                 | `SELECT CONV(15, 10, 2); -> 1111`                            |
| CONVERT(s USING cs)                                          | 函数将字符串 s 的字符集变成 cs                               | `SELECT CHARSET('ABC') ->utf-8     SELECT CHARSET(CONVERT('ABC' USING gbk)) ->gbk` |
| CURRENT_USER()                                               | 返回当前用户                                                 | `SELECT CURRENT_USER(); -> guest@%`                          |
| DATABASE()                                                   | 返回当前数据库名                                             | `SELECT DATABASE();    -> runoob`                            |
| IF(expr,v1,v2)                                               | 如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。       | `SELECT IF(1 > 0,'正确','错误')     ->正确`                  |
| [IFNULL(v1,v2)](https://www.runoob.com/mysql/mysql-func-ifnull.html) | 如果 v1 的值不为 NULL，则返回 v1，否则返回 v2。              | `SELECT IFNULL(null,'Hello Word') ->Hello Word`              |
| ISNULL(expression)                                           | 判断表达式是否为 NULL                                        | `SELECT ISNULL(NULL); ->1`                                   |
| LAST_INSERT_ID()                                             | 返回最近生成的 AUTO_INCREMENT 值                             | `SELECT LAST_INSERT_ID(); ->6`                               |
| NULLIF(expr1, expr2)                                         | 比较两个字符串，如果字符串 expr1 与 expr2 相等 返回 NULL，否则返回 expr1 | `SELECT NULLIF(25, 25); ->`                                  |
| SESSION_USER()                                               | 返回当前用户                                                 | `SELECT SESSION_USER(); -> guest@%`                          |
| SYSTEM_USER()                                                | 返回当前用户                                                 | `SELECT SYSTEM_USER(); -> guest@%`                           |
| USER()                                                       | 返回当前用户                                                 | `SELECT USER(); -> guest@%`                                  |
| VERSION()                                                    | 返回数据库的版本号                                           | `SELECT VERSION() -> 5.6.34`                                 |

####  MySQL 8.0 版本新增的一些常用函数：

| 函数            | 描述                                   | 实例                                                         |
| :-------------- | :------------------------------------- | :----------------------------------------------------------- |
| JSON_OBJECT()   | 将键值对转换为 JSON 对象               | `SELECT JSON_OBJECT('key1', 'value1', 'key2', 'value2')`     |
| JSON_ARRAY()    | 将值转换为 JSON 数组                   | `SELECT JSON_ARRAY(1, 2, 'three')`                           |
| JSON_EXTRACT()  | 从 JSON 字符串中提取指定的值           | `SELECT JSON_EXTRACT('{"name": "John", "age": 30}', '$.name')` |
| JSON_CONTAINS() | 检查一个 JSON 字符串是否包含指定的值   | `SELECT JSON_CONTAINS('{"name": "John", "age": 30}', 'John', '$.name')` |
| ROW_NUMBER()    | 为查询结果中的每一行分配一个唯一的数字 | `SELECT ROW_NUMBER() OVER(ORDER BY id) AS row_number, name FROM users` |
| RANK()          | 为查询结果中的每一行分配一个排名       | `SELECT RANK() OVER(ORDER BY score DESC) AS rank, name, score FROM students` |

### mysql运算符

本章节我们主要介绍 MySQL 的运算符及运算符的优先级。 MySQL 主要有以下几种运算符：

- 算术运算符
- 比较运算符
- 逻辑运算符
- 位运算符

#### 算术运算符

MySQL 支持的算术运算符包括:

| 运算符   | 作用 |
| :------- | :--- |
| +        | 加法 |
| -        | 减法 |
| *        | 乘法 |
| / 或 DIV | 除法 |
| % 或 MOD | 取余 |

在除法运算和模运算中，如果除数为0，将是非法除数，返回结果为NULL。

![image-20230923192808702](C:\Users\19851\AppData\Roaming\Typora\typora-user-images\image-20230923192808702.png)

#### 比较运算符

SELECT 语句中的条件语句经常要使用比较运算符。通过这些比较运算符，可以判断表中的哪些记录是符合条件的。比较结果为真，则返回 1，为假则返回 0，比较结果不确定则返回 NULL。

| 符号            | 描述                       | 备注                                                         |
| :-------------- | :------------------------- | :----------------------------------------------------------- |
| =               | 等于                       |                                                              |
| <>, !=          | 不等于                     |                                                              |
| >               | 大于                       |                                                              |
| <               | 小于                       |                                                              |
| <=              | 小于等于                   |                                                              |
| >=              | 大于等于                   |                                                              |
| BETWEEN         | 在两值之间                 | >=min&&<=max                                                 |
| NOT BETWEEN     | 不在两值之间               |                                                              |
| IN              | 在集合中                   |                                                              |
| NOT IN          | 不在集合中                 |                                                              |
| <=>             | 严格比较两个NULL值是否相等 | 两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0 |
| LIKE            | 模糊匹配                   |                                                              |
| REGEXP 或 RLIKE | 正则式匹配                 |                                                              |
| IS NULL         | 为空                       |                                                              |
| IS NOT NULL     | 不为空                     |                                                              |

![image-20230923193024825](C:\Users\19851\AppData\Roaming\Typora\typora-user-images\image-20230923193024825.png)

#### 逻辑运算符

逻辑运算符用来判断表达式的真假。如果表达式是真，结果返回 1。如果表达式是假，结果返回 0。

| 运算符号 | 作用     |
| :------- | :------- |
| NOT 或 ! | 逻辑非   |
| AND      | 逻辑与   |
| OR       | 逻辑或   |
| XOR      | 逻辑异或 |

![image-20230923193120407](C:\Users\19851\AppData\Roaming\Typora\typora-user-images\image-20230923193120407.png)

#### 位运算符

位运算符是在二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。

| 运算符号 | 作用     |
| :------- | :------- |
| &        | 按位与   |
| \|       | 按位或   |
| ^        | 按位异或 |
| !        | 取反     |
| <<       | 左移     |
| >>       | 右移     |

![image-20230923193222647](C:\Users\19851\AppData\Roaming\Typora\typora-user-images\image-20230923193222647.png)

#### 运算符优先级

![img](https://www.runoob.com/wp-content/uploads/2018/11/1011652-20170416163043227-1936139924.png)

最低优先级为： **:=**。

最高优先级为： **!**、**BINARY**、 **COLLATE**。

### mysql分组

group by根据一个或多个列对结果集进行分组

在分组的列上我们可以使用count、sum、avg等函数

**group语法**

```sql
select column_name, function(column_name)
from table_name
where column_name operator value
group by column_name
```

![image-20230923194034467](C:\Users\19851\AppData\Roaming\Typora\typora-user-images\image-20230923194034467.png)

使用with rollup可以实现在分组统计数据基础上再进行相同的统计

![image-20230923195000442](C:\Users\19851\AppData\Roaming\Typora\typora-user-images\image-20230923195000442.png)

### mysql  having子句

在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。

HAVING 子句可以让我们筛选分组后的各组数据

语法：

```sql
select column1, aggregate_function(column2)
from table_name
group by column1
having condition;
```

查找总访问量大于200的网站

```sql
select websites.name, websites.url, sum(access_log.count) as nums from(access_log inner join websites on access_log.site_id=websites.id)
group by websites.name
having sum(access_log.count)>200;
```

现在我们想要查找总访问量大于 200 的网站，并且 alexa 排名小于 200。

```sql
select websites.name, sum(access_log.count) as nums from websites inner join access_log on websites.id=access_log.site_id
where websites.alexa<200
group by websites.name
having sum(access_log.count)>200;
```

### mysql存储过程

[MySQL---存储过程详解_ʜғ的博客-CSDN博客](https://blog.csdn.net/whf_a/article/details/114871866)

